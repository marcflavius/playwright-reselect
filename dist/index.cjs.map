{"version":3,"sources":["../src/index.ts","../src/utils/reselect.ts"],"sourcesContent":["export { reselectTree } from './utils/reselect.js';\nexport type { Ctx, TreeDescription, BranchDescription, LocatorExpect } from './utils/reselect.types.js';","import type {\n\tTreeDescription,\n\tNodeFromDesc as NodeFromDesc,\n\tWrapDebugType,\n\tCtx,\n\tNodeDescription,\n} from './reselect.types.js';\nimport { Page, Locator as L, Locator, expect } from '@playwright/test';\n\n/**\n * Root of the \"in()\" tree.\n */\nexport type InReturnFromDesc<T extends TreeDescription> = {\n\t[K in keyof T]: () => NodeFromDesc<T[K]>;\n};\n\nfunction createExpectChain(locator: Locator) {\n\tconst base = expect(locator); // real Playwright expect object\n\n\tfunction wrapMatcherObject(obj: any, parentChain: any) {\n\t\tconst chain: any = {};\n\n\t\tfor (const key of Object.keys(obj)) {\n\t\t\tconst value = obj[key];\n\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tchain[key] = async (...args: any[]) => {\n\t\t\t\t\tawait value.apply(obj, args);\n\t\t\t\t\treturn parentChain; // return top chain\n\t\t\t\t};\n\t\t\t}\n\n\t\t\telse if (typeof value === 'object' && value !== null) {\n\t\t\t\t// Nested matchers like `.not`\n\t\t\t\tchain[key] = wrapMatcherObject(value, parentChain);\n\t\t\t}\n\t\t}\n\n\t\treturn chain;\n\t}\n\n\tconst topChain: any = {};\n\tObject.assign(topChain, wrapMatcherObject(base, topChain));\n\n\treturn topChain as {\n\t\t[K in keyof ReturnType<typeof expect<Locator>>]:\n\t\tReturnType<typeof expect<Locator>>[K] extends (...a: infer A) => any\n\t\t? (...a: A) => Promise<any>\n\t\t: ReturnType<typeof expect<Locator>>[K] extends object\n\t\t? typeof createExpectChain extends (...args: any[]) => infer T ? T : never\n\t\t: never;\n\t};\n}\n\n\nfunction wrapLocator(locator: L): WrapDebugType {\n\t//@ts-ignore\n\treturn Object.assign(locator, {\n\t\tdebug: debug(locator),\n\t\texpectChain: () => createExpectChain(locator),\n\t});\n}\n\nfunction prettyHtml(html: string): string {\n\tconst formatted: string[] = [];\n\tconst regex = /(>)(<)(\\/*)/g;\n\thtml = html.replace(regex, '$1\\n$2$3'); // split tags to separate lines\n\n\tlet indent = 0;\n\tconst padding = '  ';\n\n\thtml.split('\\n').forEach((line) => {\n\t\tconst trimmed = line.trim();\n\n\t\tif (trimmed.match(/^<\\/\\w/)) {\n\t\t\t// closing tag â†’ decrease indent\n\t\t\tindent = Math.max(indent - 1, 0);\n\t\t}\n\n\t\tformatted.push(padding.repeat(indent) + trimmed);\n\n\t\tif (trimmed.match(/^<\\w[^>]*[^\\/]>$/)) {\n\t\t\t// opening tag with children\n\t\t\tindent++;\n\t\t}\n\t});\n\n\treturn formatted.join('\\n');\n}\n\nfunction debug(locator: Locator) {\n\treturn async () => {\n\t\ttry {\n\t\t\tconst html = await locator.evaluate((el: HTMLElement) => el.outerHTML);\n\t\t\tconst output = `\\n[DEBUG] ${locator.toString()}\\n${prettyHtml(html)}\\n`;\n\t\t\tconsole.log(output);\n\t\t\treturn output;\n\t\t} catch (err) {\n\t\t\tconsole.error('[DEBUG ERROR] Could not read innerHTML:', err);\n\t\t\treturn err;\n\t\t}\n\t};\n}\n\n/**\n * Build a node object from its description.\n */\nfunction createNode<D extends NodeDescription>(ctx: Ctx, desc: D): NodeFromDesc<D> {\n\tconst node: any = {\n\t\tget: () => {\n\t\t\t// @ts-ignore\n\t\t\tconst locator = ctx.page.locator(ctx.locator['_selector']);\n\t\t\tctx.locator = ctx.page.locator(':root'); // reset after get() call\n\t\t\treturn wrapLocator(locator);\n\t\t},\n\t\tdebug: debug(ctx.locator),\n\t\texpectChain: () => createExpectChain(ctx.locator),\n\t};\n\n\t// Children\n\tif (desc.children) {\n\t\tfor (const key of Object.keys(desc.children)) {\n\t\t\tconst childDesc = desc.children[key];\n\t\t\tnode[key] = () => {\n\t\t\t\tchildDesc.build(ctx); // concatenate the ctx\n\t\t\t\treturn createNode(ctx, childDesc);\n\t\t\t};\n\t\t}\n\t}\n\t// Custom methods\n\tif (desc.custom) {\n\t\tfor (const key of Object.keys(desc.custom)) {\n\t\t\tconst fn = desc.custom[key];\n\t\t\tnode[key] = (...args: any[]) => {\n\t\t\t\tconst result = fn(ctx, ...args);\n\t\t\t\tctx.locator = ctx.page.locator(':root'); // reset after custom getter call\n\t\t\t\treturn wrapLocator(result);\n\t\t\t};\n\t\t}\n\t}\n\n\tObject.assign(node, {\n\t\tinspect: () => {\n\t\t\t// @ts-ignore\n\t\t\tconsole.log('[INSPECT] ' + ctx.locator['_selector']);\n\t\t\treturn node;\n\t\t}\n\t});\n\treturn node;\n}\n\n/**\n * Build the root object returned by in().\n */\nfunction createIn<T extends TreeDescription>(ctx: Ctx): InReturnFromDesc<T> {\n\tconst root: any = {};\n\tfor (const rootKey of Object.keys(ctx.descriptor)) {\n\t\tconst nodeDesc = ctx.descriptor[rootKey];\n\t\troot[rootKey] = () => {\n\t\t\tnodeDesc.build(ctx); // concatenate the ctx\n\t\t\treturn createNode(ctx, nodeDesc);\n\t\t};\n\t}\n\n\treturn root;\n}\n\n/**\n * Main TestLocatorResolver class.\n */\nexport class TestLocatorResolver<T> implements Ctx {\n\tpage: Page;\n\tdescriptor: any;\n\tlocator: L;\n\n\t/**\n\t * Creates an instance of TestLocatorResolver.\n\t * @param {Page} page\n\t * @param {*} descriptor\n\t *  representation of the testing UI logic\n\t *  Each node MUST have:\n\t *    - entry: string\n\t *    - build(ctx: Ctx): void\n\t *  and MAY have:\n\t *    - custom: { [name]: (ctx, ...args) => any }\n\t *    - children: LocatorTreeDescription\n\t *\n\t *  Example abstract node:\n\t *\n\t *  ```ts\n\t *  someNode: {\n\t *    entry: 'some-node-id',\n\t *    build: (ctx: Ctx) => {\n\t *      ctx.locator = ctx.page.locator('#some-node-id');\n\t *    },\n\t *    custom: {\n\t *      doSomething: (ctx: Ctx, x: number) => x * 2,\n\t *    },\n\t *    children: {\n\t *      // recursion...\n\t *    }\n\t *  }\n\t *  ```\n\t *\n\t *  Changing this object changes BOTH the runtime behavior and\n\t * @memberof TestLocatorResolver\n\t */\n\tconstructor(page: Page, descriptor: T) {\n\t\tif (!descriptor) {\n\t\t\tthrow new Error('new TestLocatorResolver(page, descriptor): descriptor is required');\n\t\t}\n\t\tif (!page) {\n\t\t\tthrow new Error('new TestLocatorResolver(page, descriptor): page is required');\n\t\t}\n\t\tthis.page = page;\n\t\tthis.descriptor = descriptor;\n\t\t// @ts-ignore\n\t\tthis.locator = page.locator(':root'); // initial, will be overwritten by build()\n\t\tObject.assign(this, createIn(this));\n\t}\n}\n\nexport const reselectTree = <T extends TreeDescription>(treeDescription: T) => (page: Page): InReturnFromDesc<T> => {\n\t// @ts-ignore\n\treturn new TestLocatorResolver<T>(page, treeDescription);\n};\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,kBAAAE,IAAA,eAAAC,EAAAH,GCOA,IAAAI,EAAoD,4BASpD,SAASC,EAAkBC,EAAkB,CAC5C,IAAMC,KAAO,UAAOD,CAAO,EAE3B,SAASE,EAAkBC,EAAUC,EAAkB,CACtD,IAAMC,EAAa,CAAC,EAEpB,QAAWC,KAAO,OAAO,KAAKH,CAAG,EAAG,CACnC,IAAMI,EAAQJ,EAAIG,CAAG,EAEjB,OAAOC,GAAU,WACpBF,EAAMC,CAAG,EAAI,SAAUE,KACtB,MAAMD,EAAM,MAAMJ,EAAKK,CAAI,EACpBJ,GAIA,OAAOG,GAAU,UAAYA,IAAU,OAE/CF,EAAMC,CAAG,EAAIJ,EAAkBK,EAAOH,CAAW,EAEnD,CAEA,OAAOC,CACR,CAEA,IAAMI,EAAgB,CAAC,EACvB,cAAO,OAAOA,EAAUP,EAAkBD,EAAMQ,CAAQ,CAAC,EAElDA,CAQR,CAGA,SAASC,EAAYV,EAA2B,CAE/C,OAAO,OAAO,OAAOA,EAAS,CAC7B,MAAOW,EAAMX,CAAO,EACpB,YAAa,IAAMD,EAAkBC,CAAO,CAC7C,CAAC,CACF,CAEA,SAASY,EAAWC,EAAsB,CACzC,IAAMC,EAAsB,CAAC,EACvBC,EAAQ,eACdF,EAAOA,EAAK,QAAQE,EAAO;AAAA,KAAU,EAErC,IAAIC,EAAS,EACPC,EAAU,KAEhB,OAAAJ,EAAK,MAAM;AAAA,CAAI,EAAE,QAASK,GAAS,CAClC,IAAMC,EAAUD,EAAK,KAAK,EAEtBC,EAAQ,MAAM,QAAQ,IAEzBH,EAAS,KAAK,IAAIA,EAAS,EAAG,CAAC,GAGhCF,EAAU,KAAKG,EAAQ,OAAOD,CAAM,EAAIG,CAAO,EAE3CA,EAAQ,MAAM,kBAAkB,GAEnCH,GAEF,CAAC,EAEMF,EAAU,KAAK;AAAA,CAAI,CAC3B,CAEA,SAASH,EAAMX,EAAkB,CAChC,MAAO,UAAY,CAClB,GAAI,CACH,IAAMa,EAAO,MAAMb,EAAQ,SAAUoB,GAAoBA,EAAG,SAAS,EAC/DC,EAAS;AAAA,UAAarB,EAAQ,SAAS,CAAC;AAAA,EAAKY,EAAWC,CAAI,CAAC;AAAA,EACnE,eAAQ,IAAIQ,CAAM,EACXA,CACR,OAASC,EAAK,CACb,eAAQ,MAAM,0CAA2CA,CAAG,EACrDA,CACR,CACD,CACD,CAKA,SAASC,EAAsCC,EAAUC,EAA0B,CAClF,IAAMC,EAAY,CACjB,IAAK,IAAM,CAEV,IAAM1B,EAAUwB,EAAI,KAAK,QAAQA,EAAI,QAAQ,SAAY,EACzD,OAAAA,EAAI,QAAUA,EAAI,KAAK,QAAQ,OAAO,EAC/Bd,EAAYV,CAAO,CAC3B,EACA,MAAOW,EAAMa,EAAI,OAAO,EACxB,YAAa,IAAMzB,EAAkByB,EAAI,OAAO,CACjD,EAGA,GAAIC,EAAK,SACR,QAAWnB,KAAO,OAAO,KAAKmB,EAAK,QAAQ,EAAG,CAC7C,IAAME,EAAYF,EAAK,SAASnB,CAAG,EACnCoB,EAAKpB,CAAG,EAAI,KACXqB,EAAU,MAAMH,CAAG,EACZD,EAAWC,EAAKG,CAAS,EAElC,CAGD,GAAIF,EAAK,OACR,QAAWnB,KAAO,OAAO,KAAKmB,EAAK,MAAM,EAAG,CAC3C,IAAMG,EAAKH,EAAK,OAAOnB,CAAG,EAC1BoB,EAAKpB,CAAG,EAAI,IAAIE,IAAgB,CAC/B,IAAMqB,EAASD,EAAGJ,EAAK,GAAGhB,CAAI,EAC9B,OAAAgB,EAAI,QAAUA,EAAI,KAAK,QAAQ,OAAO,EAC/Bd,EAAYmB,CAAM,CAC1B,CACD,CAGD,cAAO,OAAOH,EAAM,CACnB,QAAS,KAER,QAAQ,IAAI,aAAeF,EAAI,QAAQ,SAAY,EAC5CE,EAET,CAAC,EACMA,CACR,CAKA,SAASI,EAAoCN,EAA+B,CAC3E,IAAMO,EAAY,CAAC,EACnB,QAAWC,KAAW,OAAO,KAAKR,EAAI,UAAU,EAAG,CAClD,IAAMS,EAAWT,EAAI,WAAWQ,CAAO,EACvCD,EAAKC,CAAO,EAAI,KACfC,EAAS,MAAMT,CAAG,EACXD,EAAWC,EAAKS,CAAQ,EAEjC,CAEA,OAAOF,CACR,CAKO,IAAMG,EAAN,KAA4C,CAqClD,YAAYC,EAAYC,EAAe,CACtC,GAAI,CAACA,EACJ,MAAM,IAAI,MAAM,mEAAmE,EAEpF,GAAI,CAACD,EACJ,MAAM,IAAI,MAAM,6DAA6D,EAE9E,KAAK,KAAOA,EACZ,KAAK,WAAaC,EAElB,KAAK,QAAUD,EAAK,QAAQ,OAAO,EACnC,OAAO,OAAO,KAAML,EAAS,IAAI,CAAC,CACnC,CACD,EAEaO,EAA2CC,GAAwBH,GAExE,IAAID,EAAuBC,EAAMG,CAAe","names":["index_exports","__export","reselectTree","__toCommonJS","import_test","createExpectChain","locator","base","wrapMatcherObject","obj","parentChain","chain","key","value","args","topChain","wrapLocator","debug","prettyHtml","html","formatted","regex","indent","padding","line","trimmed","el","output","err","createNode","ctx","desc","node","childDesc","fn","result","createIn","root","rootKey","nodeDesc","TestLocatorResolver","page","descriptor","reselectTree","treeDescription"]}